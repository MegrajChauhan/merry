## Input File Structure

### A Little Bit of History

When Merry was still a virtual machine, it used the **BEB** (**Broadly Emitted Binary**) input file format — a flexible, easily expandable structure designed to support every imaginable core type.  
The format was highly efficient, requiring minimal metadata to describe the entire input file while allowing debuggers and language processors to include their own custom sections that Merry VM ignored entirely.

Although it’s unnecessary to explain the **BEB** format in detail here, it’s worth mentioning because it played a major role in shaping the current file format. The new system trades some efficiency for far greater flexibility.

---

### Need for a Change

Originally, Merry enforced a single, unified memory model for all core types. No matter what kind of core you created, it **had** to use the same memory structure imposed by Merry.  
This worked well for interoperability — where different cores needed to exchange data — but it completely ignored the need for **custom memory management** optimized for each core’s unique requirements.

For example:
- A core simulating the **8086** architecture might need a fixed-size array of bytes.  
- A core specialized in **networking** might require a memory structure where client data is organized across separate virtual pages.

Under the old architecture, cores had to build their own virtual layers on top of Merry’s virtual memory to simulate the behavior they actually needed. This made development cumbersome and inefficient.

Eventually, the entire memory model was abandoned. Now, **each core defines its own file format and memory structure**, removing the old limitations entirely.  
As a result, file formats are no longer unified, and cores no longer share a single memory model. This change introduces near-limitless flexibility — at the cost of additional overhead when supporting multiple formats simultaneously.

Each core type can also define its own method of communicating with other cores, further improving modularity and design freedom.

---

### MMF v1.0

The current file format used by Merry Nexus is the **MMF** (**Merry Metadata File**).  
As the name implies, it is purely a metadata file — simple in design, containing just one major section. All numeric values in the file, except for paths, are stored in **big-endian** format.

The structure is divided into two parts:

1. **First 8 Bytes**  
2. **Entry Table**

#### First 8 Bytes

```hex 
    00 00 00 00 00 00 00 00
```

- The first **three bytes** are the **magic bytes**: `0x4D 0x4D 0x46`, which represent “MMF” in ASCII.  
- The remaining **five bytes** indicate the **number of entries** in the Entry Table.

> ⚠️ The number of entries must never exceed the number of core types supported by Merry.  
> Each core type can only appear **once** — the reason for this restriction is explained below.

---

#### Entry Table

Each entry in the table has a **dynamic length**, but the general structure is:

```hex
    00 00 00 00 00 00 00 00
    <null-terminated string>
```

- The first **8 bytes** specify the **core type** (in big-endian format).  
  This must correspond to a valid core type.  
- Following this is a **null-terminated string** that represents the **path to the input file** for that specific core type.  
  The path can be **relative** (to the directory where Merry is run) or **absolute**.

The number of entries in the table must match the value specified in the first 8 bytes.

---

### So Many File Formats!

Yes — that’s the trade-off for flexibility.  
The alternative would be forcing all cores to use a single, unified file format for simplicity.  
However, the current design allows each core type to define how it wants to read and interpret its input files in the most efficient way possible.  

This freedom enables techniques like **lazy loading**, **on-demand data allocation**, or other optimizations that suit each core’s execution model.

---

### Why One Entry per Core Type?

Merry keeps an internal list mapping each core type to its corresponding input file.  
When a new core is created, it uses this list to locate and load the correct input file automatically.  

If multiple input files were allowed per core type, programs would have to manage those mappings manually — tracking and providing the correct file paths themselves.  

While Merry will eventually provide mechanisms for inter-core programs to load additional input files, this feature is **not supported yet**.

---

### Example

Here’s an example of a Merry Metadata File (MMF), assuming Merry supports **10 different core types**:

```hex
0x4D 0x4D 0x46 0x00 0x00 0x00 0x00 0x05
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x09
t e s t f i l e . f 0x00 ...
```


- The first 8 bytes indicate that there are **5 entries** in the table.  
- The first entry is for **core type 9**, and its corresponding input file is **testfile.f**.  
- The remaining entries follow the same format sequentially.

---

